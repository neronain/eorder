<?
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
// -------------------------------------------------------------------------------
// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src


class Inc_Mailer{
	/**
	 * Function for sending email from system
	 *
	 * @param	string	$toemail 		Destination Email
	 * @param	string	$subject 		Email Subject
	 * @param	string	$messages		Email content
	 * @param	string 	$fromemail		From Email
	 * @param	string	$replyemail		Reply-To Email
	 * @param	string	$sendername		Sender Name
	 * @param	string	$custom_params	Custom Parameters
	 *
	 * @return	boolean					Return if can send email or not				
	 */
	public static function mailer($toemail,$subject='',$messages='',$fromemail,$replyemail='',$sendername='',$custom_params=NULL){
		$error = Inc_Mailer::bkmailer($toemail,$subject,$messages,$fromemail,$replyemail,$sendername,$custom_params);
		if($error !== false){
			$delivery = new MD_ARDelivery();
			$delivery->cache_email = $toemail;
			$delivery->member_id = 1;
			$delivery->cache_fhq_sendfrom_type = CONST_MAINMAILSYSTEM;
			$delivery->status = 'PENDING';
			$delivery->sendind_type = 'CUSTOM';
			$delivery->date_sent = Inc_Var::DatePHPToMysql(mktime()+60*5);
			$delivery->error_code = $error->CODE;

			$custom = array();
			$custom['subject'] = $subject;
			$custom['fromemail'] = $fromemail;
			$custom['replyemail'] = $replyemail;
			$custom['sendername'] = $sendername;
			$custom['messages'] = $messages;
			$custom['custom_params'] = $custom_params;
			$delivery->custom = urlencode(serialize($custom));
			$delivery->local_unlock_writeable = true;
			$delivery->Update();

		}
		return true;
	}
	//
	//
	//
	//
	//
	// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
	//
	//
	//
	//
	//
	public static function bkmailer($toemail,$subject='',$messages='',$fromemail,$replyemail='',$sendername='',$custom_params=NULL){
		global $CONFIG;
		
		

		
		
		include_once "../../lib/swift/lib/swift_required.php";

		$logdir = prepath().'../log/mailer';
		$logfile = $logdir.'/'.'log_mail_'.date('Y-m-d').'.log';
		$errfile = $logdir.'/'.'error_mail_'.date('Y-m-d').'.log';

		
		//if(Conf()->DEBUG) {
		//	error_log("to:$toemail\nfrom:$fromemail\nreply:$replyemail\nsender:$sendername\nsubject:$subject\n\n$messages\n----------------------------------------\n",3,$logfile);
		//	return;
		//}		
		
		
		$mail_encoder = NULL;
		
		$replyemail_alt = $fromemail;
		
		
		$username = "XXX";
		$password = "XXX";
	

		if($username=='XXX'){
			$mail_server = WHITELABELMAILLER_SMTP_KEY;
			$MAILCFG = Conf_Mail::MAILCFG();
			
			$fromname = WHITELABELMAILLER_SENDER_NAME;

			$port       = $MAILCFG[$mail_server]['port'];  // set the SMTP server port
			$host       = $MAILCFG[$mail_server]['host'];	// SMTP server
			$hostname   = $MAILCFG[$mail_server]['hostname'];
			$username   = $MAILCFG[$mail_server]['username'];  // SMTP server username
			$password	= $MAILCFG[$mail_server]['password'];  // SMTP server password
		}elseif($username=='10WBC'){
			//HARDCODE 10wbc
			//$autoresponder = MD_Optin::BuildByID(78945);
			$autoresponder = MD_Optin::BuildByID(126825);

			$fromemail =  $autoresponder->fhq_send_fromemail;
			$fromname = $autoresponder->fhq_send_fromname;
			$port       = $autoresponder->fhq_smtp_port;  // set the SMTP server port
			$host       = $autoresponder->fhq_smtp_server;	// SMTP server
			$hostname   = $autoresponder->fhq_smtp_server;
			$username   = $autoresponder->fhq_smtp_username; // SMTP server username
			$password   = $autoresponder->fhq_smtp_password; // SMTP server password
		}else{
			$port       = 25;                    // set the SMTP server port
			$host       = "mail.hexadentallab.com";		//mail.fusionhq.com"; // SMTP server
			$hostname   = "hexadentallab.com";
			$username   = $username;     // SMTP server username
			$password   = $password;            // SMTP server password
		}
		
		if($replyemail==''){
			$replyemail = $replyemail_alt;
		}
		if($sendername!=''){
			$fromname = $sendername;
		}
		
		$body = $messages;
		$body = preg_replace('/\\\\/','', $body);

		try {
			$transport = Swift_SmtpTransport::newInstance($host, $port)
			->setUsername($username)
			->setPassword($password);
			
			$mailer = Swift_Mailer::newInstance($transport);
			
			$message = Swift_Message::newInstance()
			->setSubject($subject)
			->setFrom(array($fromemail => $fromname))
			->setReplyTo(array($replyemail))
			->setTo(array($toemail));
			
			
			if($mail_encoder=='7bit'){
				$message->setEncoder(new Swift_Mime_ContentEncoder_PlainContentEncoder($mail_encoder));
			}
			
			if(strpos($body,"<br/>")===false && strpos($body,"<br>")===false && strpos($body,"</p>")===false && strpos($body,"</span>")===false){
				$message->setBody($body, 'text/plain');
			}else{
				$message->setBody($body, 'text/html');
			}
			
			if($custom_params['attach_pdcship_csv']>0){
				$pdcship = MD_PdcShip::BuildByID($custom_params['attach_pdcship_csv']);
				$attachdata = $pdcship->GenerateCSV();
			
				if($pdcship->member_id==758691){
					$ext = 'txt';
					$content_type = 'text/plain';
				}else{
					$ext = 'csv';
					$content_type = 'text/csv';
				}
			
				$tmpFile = prepath()."../tmp/shipping_".$pdcship->transactionid.".".$ext."";
				file_put_contents($tmpFile,$attachdata);
					
				$attachment = Swift_Attachment::fromPath($tmpFile, $content_type);
				$message->attach($attachment);
			}
			
			
			
			
			
			
			
			
			$result = $mailer->send($message);
			if($result){
				error_log("\n ".'['.date('Y-m-d H:i:s').']'." Inc_Mailer::mailer($toemail,$subject,messages,$fromemail,$replyemail,$sendername,$username) [$host:$port] : SUCCESS!\n", 3, $errfile);
			}
			return false;
		} catch(Exception $e){
			error_log("\n ".'['.date('Y-m-d H:i:s').']'." Inc_Mailer::mailer($toemail,$subject,messages,$fromemail,$replyemail,$sendername,$username) [$host:$port] : FAILED : ".$e->getMessage()."\n", 3, $errfile);
			return $e;
		}
		
		return false;
		
		
	}


	//
	//
	//
	//
	//
	// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
	//
	//
	//
	//
	//
	public static function extractMessage($data,&$gHeader){
		$lines = explode("\n", $data);
		$splittingheaders = true;
		$cacheHeadText = "";
		$gMessage = "";

		for ($i=0; $i<count($lines); $i++) {
			if ($splittingheaders) {
				//echo "H>".$lines[$i]."";
				// this is a header
				//$headers .= $lines[$i]."\n";
				// look out for special headers
				if (preg_match("/^(.+?): ?(.*)/s", $lines[$i], $matches)) {
					$cacheHeadText = $matches[1];
					$gHeader[$cacheHeadText] = $matches[2];
					//echo "[Match]\n";
				}else{
					$gHeader[$cacheHeadText].= $lines[$i];
					//echo "[^Match]\n";
				}
			} else {
				//echo " >".$lines[$i]."\n";
				// not a header, but message
				$gMessage .= $lines[$i]."\n";
			}

			if (trim($lines[$i])=="" && $splittingheaders) {
				//echo "------------------------------\n";
				// empty line, header section has ended
				$splittingheaders = false;
			}
		}
		return $gMessage;
	}
	//
	//
	//
	//
	//
	// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
	//
	//
	//
	//
	//
	public static function CutEmailData($emaildata,$type = ''){
		$emaildata = str_replace("\r\n","\n",$emaildata);
		$gHeader = array();
		$gMessage = Inc_Mailer::extractMessage($emaildata,$gHeader);
		//echo "\nGHEADER -----------------------------------------\n";
		//var_export($gHeader['Content-Type']);
		$lMessage= array();
		if (preg_match('/boundary="?([\w\d=:-]+)"?/s', $gHeader['Content-Type'], $matches)) {

			$boundary = $matches[1];
			$gMessage = preg_replace("/--[\n ]*$/","\n",$gMessage);
			$messageAr = explode("--".$boundary."\n", $gMessage);

			$lMessage = array();
			$lMessageIndex = 0;
			$BoundaryMessage = array();
			for($j=0;$j<count($messageAr);$j++){
				if(trim($messageAr[$j])=='')continue;
				$ExplodeMSGAr = explode("\n",$messageAr[$j]);
				foreach($ExplodeMSGAr as $messagePara) {
					$BoundaryHeaderFlag = false;
					if(preg_match("/^(.*): (.*)/", $messagePara, $matches)) {
						$lMessage[$lMessageIndex]['header'][$matches[1]] = $matches[2];
						$BoundaryHeader = $matches[1];
						$BoundaryHeaderFlag = true;
					}
					if(trim($messaePara) == "") break;
					if(!$BoundaryHeaderFlag) $lMessage[$lMessageIndex]['header'][$BoundaryHeader] .= trim($messagePara);

				}
				$lMessage[$lMessageIndex]['data'] = Inc_Mailer::extractMessage($messageAr[$j],$lMessage[$lMessageIndex]['header']);

				$lMessageIndex++;

			}
			unset($messageAr);
			unset($ExplodeMSGAr);
			unset($BoudaryHeaderFlag);
			unset($matches);

		}

		$contentType = $gHeader['Content-Type'];
		$contentTypeAr = explode(";",$contentType);
		$typeAr = explode("/",$contentTypeAr[0],2);
		$type = $typeAr[1];

		if($type=='plain'){
			$returnVar['header'] = $gHeader;
			$returnVar['data'] = $gMessage;
		}else{
			$retVarType = array();
			foreach($lMessage as $message){
				$contentType = $message['header']['Content-Type'];
				$contentTypeAr = explode(";",$contentType);
				$typeAr = explode("/",$contentTypeAr[0],2);
				$type = $typeAr[1];
				//if($type=="message/feedback-report"){
				//	$feedbackreport['data'] = Inc_Mailer::extractMessage($message['data'],$feedbackreport['header']);
				//}else
				//Check Boundary Type Attachment
				if(!array_key_exists('Content-Disposition', $message['header'])){
					$ret = array();
					$ret['data'] = $message['data'];
					$ret['header'] = $message['header'];
					$retVar[] = $ret;
					$retVarType[$type] = $ret;
				}
			}

			$returnVar['header'] = $gHeader;

			if(array_key_exists('alternative', $retVarType)){

				if (preg_match('/boundary="?([\w\d=:-]+)"?/s', $retVarType['alternative']['header']['Content-Type'], $sbmatches)) {
					$sbboundary = $sbmatches[1];
					$sbMessage = $retVarType['alternative']['data'];
					$sbMessage = preg_replace("/--[\n ]*$/","\n",$sbMessage);
					$sbMessageAr = explode("--".$sbboundary."\n", $sbMessage);
					foreach($sbMessageAr as $bMessage){
						if(strlen($bMessage) == 0) {
							continue;
						}
						$bsbMessage = Inc_Mailer::extractMessage($bMessage,$bHeader);
						$bContentType = explode(";",$bHeader['Content-Type']);
						$returnVar['header'] = $bHeader;
						$returnVar['data'] = $bsbMessage;
						if($bContentType[0] == 'text/plain'){
							break;
						}
					}
				} else {
					$returnVar['header'] = $retVarType['alternative']['header'];
					$returnVar['data'] = $retVarType['alternative']['data'];
				}
			}

			if(array_key_exists('plain', $retVarType)){
				$returnVar['header']['Content-Type'] = $retVarType['plain']['header']['Content-Type'];
				$returnVar['header']['Content-Transfer-Encoding'] = $retVarType['plain']['header']['Content-Transfer-Encoding'];
				$returnVar['data'] = $retVarType['plain']['data'];
			}

			$returnVar['Boundary'] = count($lMessage);
			foreach($lMessage as $returnBoundary) {
				$returnVar[] = $returnBoundary;
			}

		}
		return $returnVar;
	}

	//
	//
	//
	//
	//
	// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
	//
	//
	//
	//
	//
	public static function AttachFileFromBoundary($BoundaryAR,$FilePath = "",$ReturnBinnary = true){

		#Example Inc_Mailer::AttachFileFromBoundary($plain[$i],$_SERVER["DOCUMENT_ROOT"].'/tmp/'.time().'_%Filename%',true);

		$returnAR = array();
	$AttachFileFlag = false;
	//print_r($BoundaryAR['header']['Content-Disposition']);
	if(preg_match('/(filename|name|file)\*?=(.+)/', $BoundaryAR['header']['Content-Disposition'], $Fmatches)) $AttachFileFlag = true;
	//print_r($Fmatches);
	if($AttachFileFlag){
		$RAttachFilename = $Fmatches[2];

		if(preg_match('/(UTF-8)(.+)/', $Fmatches[2], $SFmatches))
		$RAttachFilename = urldecode(str_replace(array("'",'"'), '',$SFmatches[2]));

		$AttachFilename = str_replace(array("'",'"'), '',$RAttachFilename);
		$decodeattach = true;

		switch (trim($BoundaryAR['header']['Content-Transfer-Encoding'])) {
			case 'base64':  $binary = base64_decode($BoundaryAR['data']);break;
			default : $decodeattach = false;break;
		}

		if(!empty($FilePath)){
			$FilePath = str_replace("%Filename%",$AttachFilename,$FilePath);
			$fpw = fopen($FilePath,'w+');
			if($fpw){
				$returnAR['FileStatus'] = 'true';
				fwrite($fpw,$binary);
				fclose($fpw);
			}else 	$returnAR['FileStatus'] = 'false';
			$returnAR['FilePath'] = $FilePath;
			$ReturnBinnary = false;
		}

		if(preg_match('/inline(;|$)/', $BoundaryAR['header']['Content-Disposition'])){
			$returnAR['IsInline'] = true;
			$returnAR['Content-ID'] = preg_replace('/^<(.+)>$/s','$1',$BoundaryAR['header']['Content-ID']);
		}

		$returnAR['Content'] = 'file';
		$returnAR['Filename'] = $AttachFilename;
		if($ReturnBinnary) $returnAR['binary'] = $binary;

	} else {
		$returnAR['Content'] = 'plain';
		$returnAR['data'] = $BoundaryAR['data'];
	}

	return 	$returnAR;
	unset($returnAR);

	}

	//
	//
	//
	//
	//
	// DO NOT EDIT THIS FILE WHILE REWRITE DEVELOPMENT PLEASE EDIT IN /tmp/include_src
	//
	//
	//
	//
	//
	public static function RemoveEmailQuote($emaildata){
		$emaildata	= preg_replace("/[^\n]\n[^\n]+\n[^\n]+\n>.+>\n/is","\n",$emaildata);
		return $emaildata;
	}


	
	
	public static function ParseBounceStatus($code,&$isHard=NULL){
		switch($code){
			case 500: $isHard=true; return 'Address does not exist';
			case 510: $isHard=true; return 'Other address status';
			case 511: $isHard=true; return 'Bad destination mailbox address';
			case 512: $isHard=true; return 'Bad destination system address';
			case 513: $isHard=true; return 'Bad destination mailbox address syntax';
			case 514: $isHard=true; return 'Destination mailbox address ambiguous';
			case 515: $isHard=true; return 'Destination mailbox address valid';
			case 516: $isHard=true; return 'Mailbox has moved';
			case 517: $isHard=true; return 'Bad sender\'s mailbox address syntax';
			case 518: $isHard=true; return 'Bad sender\'s system address';
			case 520: $isHard=false; return 'Other or undefined mailbox status';
			case 521: $isHard=false; return 'Mailbox disabled, not accepting messages';
			case 522: $isHard=false; return 'Mailbox full';
			case 523: $isHard=true; return 'Message length exceeds administrative limit.';
			case 524: $isHard=true; return 'Mailing list expansion problem';
			case 530: $isHard=true; return 'Other or undefined mail system status';
			case 531: $isHard=false; return 'Mail system full';
			case 532: $isHard=true; return 'System not accepting network messages';
			case 533: $isHard=true; return 'System not capable of selected features';
			case 534: $isHard=true; return 'Message too big for system';
			case 540: $isHard=true; return 'Other or undefined network or routing status';
			case 541: $isHard=true; return 'No answer from host';
			case 542: $isHard=true; return 'Bad connection';
			case 543: $isHard=true; return 'Routing server failure';
			case 544: $isHard=true; return 'Unable to route';
			case 545: $isHard=false; return 'Network congestion';
			case 546: $isHard=true; return 'Routing loop detected';
			case 547: $isHard=true; return 'Delivery time expired';
			case 550: $isHard=true; return 'Other or undefined protocol status';
			case 551: $isHard=true; return 'Invalid command';
			case 552: $isHard=true; return 'Syntax error';
			case 553: $isHard=false; return 'Too many recipients';
			case 554: $isHard=true; return 'Invalid command arguments';
			case 555: $isHard=true; return 'Wrong protocol version';
			case 560: $isHard=true; return 'Other or undefined media error';
			case 561: $isHard=true; return 'Media not supported';
			case 562: $isHard=true; return 'Conversion required and prohibited';
			case 563: $isHard=true; return 'Conversion required but not supported';
			case 564: $isHard=true; return 'Conversion with loss performed';
			case 565: $isHard=true; return 'Conversion failed';
			case 570: $isHard=true; return 'Other or undefined security status';
			case 571: $isHard=true; return 'Delivery not authorized, message refused';
			case 572: $isHard=true; return 'Mailing list expansion prohibited';
			case 573: $isHard=true; return 'Security conversion required but not possible';
			case 574: $isHard=true; return 'Security features not supported';
			case 575: $isHard=true; return 'Cryptographic failure';
			case 576: $isHard=true; return 'Cryptographic algorithm not supported';
			case 577: $isHard=true; return 'Message integrity failure';
		}
		
	}
	
	
	
	
	
	
	
	
	
	


}